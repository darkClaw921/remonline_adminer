# Архитектура проекта Remonline Adminer

## Обзор
Приложение на FastAPI для работы с API Remonline, предоставляющее возможность управлять и просматривать данные о товарах, остатках и складах.

## Технологии
- **Python 3.12**
- **FastAPI** - веб-фреймворк
- **SQLAlchemy** - ORM для работы с базой данных
- **SQLite3** - база данных
- **httpx** - асинхронный HTTP клиент для работы с API
- **Pydantic** - валидация данных
- **loguru** - логирование
- **pytest** - тестирование

## Структура проекта

```
remonline_adminer/
├── main.py                          # Точка входа в приложение
├── flow.py                          # Одноразовый/CLI-флоу: синхронизация складов в БД
├── pyproject.toml                   # Конфигурация зависимостей
├── architecture.md                  # Этот файл
├── app/                             # Основное приложение
│   ├── api/                         # API endpoints
│   │   ├── __init__.py
│   │   ├── schemas.py               # Pydantic схемы для API
│   │   └── routes/                  # API роуты
│   │       ├── warehouses.py        # Роуты для складов
│   │       ├── products.py          # Роуты для товаров
│   │       └── stocks.py            # Роуты для остатков
│   ├── core/                        # Ядро приложения
│   │   └── config.py                # Конфигурация приложения
│   ├── models/                      # Модели базы данных
│   │   ├── __init__.py
│   │   ├── database.py              # Настройка базы данных
│   │   ├── warehouse.py             # Модель склада
│   │   ├── product.py               # Модель товара
│   │   ├── stock.py                 # Модель остатков
│   │   └── last_update.py           # Модель последнего обновления
│   ├── services/                    # Бизнес-логика
│   │   ├── __init__.py
│   │   ├── remonline_service.py     # Сервис для работы с API Remonline
│   │   └── background_service.py    # Сервис фоновых задач
│   └── tests/                       # Тесты
│       ├── __init__.py
│       ├── conftest.py              # Конфигурация тестов
│       ├── test_api.py              # Тесты API
│       └── test_integration.py      # Интеграционные тесты
```

## Модели данных

### Warehouse (Склад)
- `id` - первичный ключ
- `remonline_id` - ID в системе Remonline
- `name` - название склада
- `address` - адрес склада
- `is_active` - активен ли склад
- `created_at` - дата создания
- `updated_at` - дата обновления

### Product (Товар)
- `id` - первичный ключ
- `remonline_id` - ID в системе Remonline
- `name` - название товара
- `sku` - артикул
- `barcode` - штрих-код
- `description` - описание
- `price` - цена
- `category` - категория
- `is_active` - активен ли товар
- `created_at` - дата создания
- `updated_at` - дата обновления

### Stock (Остатки)
- `id` - первичный ключ
- `warehouse_id` - ID склада
- `product_id` - ID товара
- `quantity` - общее количество
- `reserved_quantity` - зарезервированное количество
- `available_quantity` - доступное количество
- `created_at` - дата создания
- `updated_at` - дата обновления

### LastUpdate (Последнее обновление)
- `id` - первичный ключ
- `entity_type` - тип сущности (warehouses, products_stocks)
- `last_updated` - время последнего обновления
- `status` - статус обновления
- `error_message` - сообщение об ошибке

## API Endpoints

### Склады (/api/v1/warehouses/)
- `GET /` - получить все склады
  - Параметры: skip, limit, active_only (по умолчанию true)
- `GET /{warehouse_id}` - получить склад по ID
- `GET /remonline/{remonline_id}` - получить склад по Remonline ID

### Товары (/api/v1/products/)
- `GET /` - получить все товары с базовыми фильтрами
  - Параметры: name, sku, category, is_active, skip, limit
- `GET /filtered` - получить товары с расширенными фильтрами по складам и остаткам
  - Параметры: name, sku, category, warehouse_ids, price_min, price_max, stock_min, stock_max, sort_by, sort_order, skip, limit
  - Поддерживает фильтрацию по конкретным складам и диапазонам остатков
  - Сортировка по складам: sort_by=wh_{warehouse_remonline_id}
- `GET /{product_id}` - получить товар по ID
- `GET /remonline/{remonline_id}` - получить товар по Remonline ID
- `POST /{product_id}/refresh` - принудительно обновить товар и его остатки (по активным складам)

### Остатки (/api/v1/stocks/)
- `GET /` - получить все остатки с фильтрами
  - Параметры: warehouse_id, product_id, min_quantity, max_quantity, include_details, skip, limit
- `GET /{stock_id}` - получить остаток по ID
- `GET /warehouse/{warehouse_id}` - получить остатки на складе
- `GET /product/{product_id}` - получить остатки товара по всем складам
 - `POST /sync_all` - запустить автосинхронизацию остатков по всем активным складам (неблокирующе)
 - `GET /sync_progress` - получить текущий прогресс автосинхронизации (processed/total, статус)

Поведение автосинхронизации:
- Приоритет — запросы к API: страницы остатков по складам запрашиваются пачками по 3 асинхронных запроса в секунду (до 3 складов одновременно).
- После получения результатов из API выполняются пакетные апсерты (товары и остатки) одной транзакцией на каждую пачку.
- Прогресс считается по складам: как только у склада приходит пустая страница — он помечается завершённым.

## Сервисы

### RemonlineService
Отвечает за взаимодействие с API Remonline:
- Получение данных из API
- Синхронизация складов
- Синхронизация товаров и остатков
- Обработка ошибок API

### BackgroundService
Управляет фоновыми задачами:
- Периодическое обновление данных
- Запуск/остановка фоновых процессов
- Логирование процесса обновления

## Конфигурация

### Переменные окружения
- `REMONLINE_API_KEY` - API ключ Remonline
- `DATABASE_URL` - URL базы данных (по умолчанию SQLite)
- `DEBUG` - режим отладки
- `LOG_LEVEL` - уровень логирования
- `UPDATE_INTERVAL_MINUTES` - интервал обновления данных

### Настройки по умолчанию
```python
REMONLINE_API_KEY = ""  # Должен быть установлен
DATABASE_URL = "sqlite:///./remonline.db"
DEBUG = False
LOG_LEVEL = "INFO"
UPDATE_INTERVAL_MINUTES = 30
```

## Запуск приложения

### Установка зависимостей
```bash
uv sync
```

### Запуск приложения
```bash
uv run main.py
```

Приложение будет доступно на `http://localhost:8000`
Документация API: `http://localhost:8000/docs`

### Ручной запуск синхронизации складов (CLI)
```bash
uv run flow.py
```
Назначение: выполнить `async`-флоу `sync_warehouses_to_db()`, который через `RemonlineService` получает все склады и записывает/обновляет их в БД. Логи — через `loguru`.

## Запуск тестов

```bash
# Все тесты
uv run pytest

# С конкретным файлом
uv run pytest app/tests/test_api.py

# С интеграционными тестами
uv run pytest app/tests/test_integration.py -v
```

## Фоновые задачи

Приложение автоматически запускает фоновые задачи при старте:
1. Синхронизация складов из API Remonline
2. Синхронизация товаров и остатков
3. Периодическое обновление данных (каждые 30 минут)

## Логирование

Используется библиотека `loguru` для структурированного логирования:
- INFO: общая информация о работе
- ERROR: ошибки выполнения
- DEBUG: детальная отладочная информация (в режиме DEBUG)

## Безопасность

- API ключ Remonline хранится в переменных окружения
- CORS настроен для всех источников (для разработки)
- Валидация входных данных через Pydantic
- Асинхронная обработка запросов

## Мониторинг

- `/health` - проверка здоровья приложения
- `/` - базовая информация о приложении
- Логи фоновых задач
- Статус подключения к базе данных

## Разработка

### Добавление новых моделей
1. Создать файл в `app/models/`
2. Импортировать в `app/models/__init__.py`
3. Добавить в `Base.metadata.create_all()`

### Добавление новых API endpoints
1. Создать роуты в `app/api/routes/`
2. Импортировать в `app/api/__init__.py`
3. Добавить схемы в `app/api/schemas.py`

### Добавление новых сервисов
1. Создать сервис в `app/services/`
2. Импортировать в `app/services/__init__.py`
3. Подключить в основном приложении

## Производительность

- Асинхронные запросы к API Remonline
- Пагинация результатов
- Оптимизированные SQL запросы
- Фоновое обновление данных

## Фронтенд (простая страница просмотра товаров)

- Статика смонтирована как `GET /static/*` из директории `app/static`
- Страница: `GET /products` возвращает `app/static/products.html`
- Дизайн: Bootstrap 5 (CDN)
- Функциональность страницы:
  - Таблица товаров со столбцами по складам: `29. Склад Китай (2272079)`, `05. Виртуальный склад (52226)`, `01. Запчасти Ростов (37746)`
  - Поиск по названию/SKU, выбор размера страницы (25/50/100), обычная пагинация по страницам
  - Фильтры: мультивыбор категорий, мультивыбор складов (загружаются из API), диапазоны цены и остатка, кнопки «Применить/Сброс»
  - Сортировка: по названию, категории, цене, общему остатку и по остаткам каждого целевого склада; порядок asc/desc
  - Для каждой позиции отображается сумма `available_quantity` по каждому из указанных складов
  - Сводка-бейджи с суммарными остатками по складам в текущей выборке
  - Динамическое отображение колонок складов: при выборе конкретных складов в фильтре показываются только выбранные склады, при отсутствии выбора — все склады
  - Колонка «Фото» показывает до 3 миниатюр; при наведении открывается полноразмерный предпросмотр
  - Колонка «Товар» компактная, с переносами строк; под названием выводятся RemID и дата последнего обновления, затем SKU
  - Отображение цен: 4 отдельные колонки для `Розничная (48388)`, `Партнёр (97150)`, `Продажа зч (377836)`, `Продажа зч VIP (555169)`
  - Доп. колонки: `Категория` (из product.category), `Общий остаток` (сумма по выбранным складам)
  - Кнопка настроек (шестерёнка) расположена справа над таблицей (рядом со спиннером) и открывает модальное окно выбора отображаемых столбцов. Настройки сохраняются в localStorage и применяются к шапке и строкам таблицы, включая динамические колонки складов
  - Новое: кнопка «Автосинхронизация» запускает полный сбор остатков по всем активным складам; рядом прогресс-бар показывает % обработанных складов из общего количества в БД
  - Постоянный статус: текстовый индикатор состояния синхронизации (не запущена/идёт/завершена/ошибка), обновляется каждые 5 секунд
  - Навигация: кнопки "Назад" и "Вперёд" для перехода между страницами, с проверкой доступности (кнопка "Назад" неактивна на первой странице, "Вперёд" - на последней)
- Используемые API эндпоинты:
  - `GET /api/v1/warehouses/?active_only=true&limit=1000` — загрузка активных складов для фильтра и заголовков таблицы
  - `GET /api/v1/products/?skip=&limit=&name=` — загрузка списка товаров без фильтров (при обычном просмотре)
  - `GET /api/v1/products/filtered?warehouse_ids=&stock_min=&...` — загрузка товаров с серверными фильтрами (при нажатии "Применить")
  - `GET /api/v1/stocks/product/{product_id}?include_details=true` — загрузка остатков товара по всем складам и маппинг по `warehouse.remonline_id`
  - `POST /api/v1/products/{id}/refresh` — принудительное обновление одного товара
  - `POST /api/v1/stocks/sync_all` — старт полной синхронизации остатков по складам
  - `GET /api/v1/stocks/sync_progress` — прогресс полной синхронизации

Страница находится в `app/static/products.html`. Маршрут и монтирование статических файлов добавлены в `main.py`.

Стили и скрипты:
- `app/static/css/products.css` — стили таблицы, колонок, миниатюр, цен и окна предпросмотра
- `app/static/js/products.js` — логика загрузки данных, рендера таблицы (в т.ч. цен), суммарных бейджей и hover-превью полноразмерного изображения возле курсора (используются `thumbnail`/`full` URL из `images_json` при наличии), а также клиентские фильтры/сортировка с кнопками «Применить/Сброс» и контекстное меню на колонке «Товар» (действия: «Обновить данные товара», «Открыть в API»). Включает динамическое управление заголовками и колонками таблицы в зависимости от выбранных складов в фильтре. Реализована обычная пагинация по страницам с размером страницы 25/50/100 элементов.

Схемы: `ProductResponse` включает `images_json` и `prices_json` для фронтенда.
Фронтенд (микро-UI):
- app/static/products.html — Bootstrap-таблица товаров, колонки цен (48388, 97150, 377836, 555169), фото с hover-превью, колонка Товар (RemID, дата, SKU), Категория, Общий остаток
- Статика: /static; роут /products отдаёт products.html
- CSS: app/static/css/products.css — таблица, миниатюры, цены, hover-превью
- JS: app/static/js/products.js — загрузка данных, рендер остатков и цен, предпросмотр фото
  - Управление столбцами: сохранение видимости в `localStorage` (ключ `columnsVisibility.v1`), чекбоксы для основных и складских колонок в модальном окне, моментальное применение без перезагрузки

API:
- /api/v1/products/ — список товаров (используются поля images_json, prices_json)
- /api/v1/stocks/product/{id} — остатки товара по складам

Схемы:
- ProductResponse: добавлены images_json, prices_json